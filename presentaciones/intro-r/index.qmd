---
title: "Introducción a R"
# date: 2025-06-02
bibliography: references.bib
csl: apa.csl
---

```{r}
#| label: setup
#| output: false

if (!require("here")) install.packages("here"); library("here")
if (!require("tidyverse")) install.packages("tidyverse"); library("tidyverse")
if (!require("palmerpenguins")) install.packages("palmerpenguins"); library("palmerpenguins")
if (!require("ggthemes")) install.packages("ggthemes"); library("ggthemes")
if (!require("flextable")) install.packages("flextable"); library("flextable")
if (!require("gt")) install.packages("gt"); library("gt")
if (!require("sysfonts")) install.packages("sysfonts"); library("sysfonts")
if (!require("showtext")) install.packages("showtext"); library("showtext")
if (!require("countdown")) install.packages("countdown"); library("countdown")

sysfonts::font_add_google(
  name = "Atkinson Hyperlegible",
  family = "atkinson"
)

showtext::showtext_auto()

# ggplot2::theme_set(
#   ggplot2::theme_classic(
#     # base_size = 18,
#     base_family = "atkinson"
#   )
# )
```

```{r}
#| label: countdown
#| echo: false
#| 
countdown_timer <- function(
    minutes = 1, 
    play_sound = TRUE, 
    font_size = "2em", 
    ...
) {
  countdown::countdown(
    minutes = minutes,
    play_sound = play_sound,
    color_border              = "#white",
    color_text                = "white",
    color_running_background  = "#009E73",
    color_running_text        = "white",
    color_finished_background = "#D55E00",
    color_finished_text       = "white",
    font_size = font_size,
    ...
  )
}
```

## Proposito 1

```{r}
#| label: figura-proposito
#| echo: false
#| warning: false
#| fig-alt: |
#|   Un diagrama de dispersión de la masa corporal frente a la longitud de la aleta de los pingüinos, con una línea de mejor ajuste de la relación entre estas dos variables superpuesta. El gráfico muestra una relación positiva, bastante lineal y relativamente fuerte entre estas dos variables. Las especies (Adelia, Barbijo y Papúa) se representan con diferentes colores y la relación entre la masa corporal y la longitud de la aleta es aproximadamente la misma para estas tres especies, y los pingüinos Papúa son #| más grandes que los pingüinos de las otras dos especies.

palmerpenguins::penguins |> 
  ggplot2::ggplot() + 
  ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  ) + 
  ggplot2::geom_point(
    ggplot2::aes(
      color = species,
      shape = species
    )
  ) + 
  ggplot2::geom_smooth(
    method = "lm"
  ) + 
  ggplot2::labs(
    title = "Masa corporal y longitud de la aleta",
    subtitle = "Dimensiones para los Pingüinos Adelie (Adelia), Chinstrap (Barbijo) y Gentoo (Papúa)",
    x = "Longitud de la aleta (mm)",
    y = "Masa corporal (g)",
    color = "Especie",
    shape = "Especie"
  ) + 
  ggplot2::theme_classic(
    base_family = "atkinson"
  ) + 
  ggthemes::scale_color_colorblind()
```

## Proposito 2

```{r}
#| label: tabla-proposito
#| echo: false
#| message: false
#| warning: false

palmerpenguins::penguins |> 
  dplyr::count(
    species,
    island,
    sex
  ) |> 
  dplyr::group_by(
    species,
    island
  ) |> 
  dplyr::mutate(
    percentage = n / sum(n) * 100
  ) |> 
  dplyr::ungroup() |> 
  flextable::flextable() |> 
  flextable::merge_v(
    j = c("species", "island")
  ) |> 
  flextable::mk_par(
    j = "species",
    value = flextable::as_paragraph(flextable::as_i(species)),
  ) |>
  flextable::colformat_char(
    j = "sex",
    na_str = "NA",
  ) |> 
  flextable::mk_par(
    i = ~ sex == "female",
    value = flextable::as_paragraph("Hembra"),
    j = "sex",
  ) |> 
  flextable::mk_par(
    i = ~ sex == "male",
    value = flextable::as_paragraph("Macho"),
    j = "sex",
  ) |> 
  flextable::set_header_labels(
    species = "Especie",
    island = "Isla",
    sex = "Sexo",
    percentage = "Porcentaje (%)"
  ) |> 
  flextable::theme_apa() |> 
  flextable::autofit() |> 
  flextable::font(
    fontname = "Atkinson Hyperlegible"
  ) |> 
  flextable::fontsize(size = 18, part = "all") |> 
  flextable::set_table_properties(width = 1, layout = "autofit")
```

## Qué es R

::: columns
::: {.column .fragment fragment-index="1" width="40%"}
> R es un sistema para computación estadística y gráficos. Consiste en un lenguaje más un entorno de ejecución con gráficos, un depurador, acceso a ciertas funciones del sistema y la capacidad de ejecutar programas almacenados en archivos de script. @rmanual

![](images/logo_r.png){fig-align="center" width="400"}
:::

::: {.column .incremental width="60%"}
-   **Lenguaje**: R es un lenguaje de programación, con sintaxis y funciones propias.
-   **Entorno de ejecución**: R proporciona un entorno en el que se pueden ejecutar programas escritos en R.
-   **Gráficos**: R incluye capacidades avanzadas para la creación de gráficos.
-   **Depurador**: R incluye herramientas para encontrar y corregir errores en sus scripts.
-   **Acceso a funciones del sistema**: R puede interactuar con el sistema operativo.
-   **Programas en scripts**: se pueden escribir programas y guardarlos en archivos de texto con extensión .R (scripts).
:::
:::

## Historia

![Algunos hitos importantes en la historia de R. Modificado de @giorgi2022.](images/timeline_r.png){fig-align="center"}

## Nuestros guías

::: columns
::: {.column .fragment width="50%"}
![R for data science de @wickham2023a. Disponible en [r4ds.hadley.nz/](https://r4ds.hadley.nz/)](images/r4ds.jpg){#r4ds fig-align="center" width="381"}
:::

::: {.column .fragment width="50%"}
![Quizá la persona más importante en el ecosistema R.](images/meme_hadley-wickham.jpg){#meme_wickham fig-align="center"}
:::
:::

## Flujo de trabajo en ciencias de datos

![En este modelo, todo comienza con la importación y limpieza de los datos. Seguido de un ciclo iterativo de transformación, visualización y modelado. Finalmente, termina con comunicar. Tomado de @wickham2023a.](images/data-science.png){#data-science-1 fig-align="center" width="600"}

## Programar es como llevar un buen matrimonio

::: fragment
![¡Ya cómete la maldita naranja!](images/meme_comete-naranja.jpeg){fig-align="center"}
:::

## Recordemos donde estamos

![[Apariencia por defecto de RStudio.](https://docs.posit.co/ide/user/ide/get-started/)](images/rstudio_ide.jpeg){fig-align="center"}

## Ejecutar código

Ejecutar código en la consola de R es muy sencillo. Sólo tienes que escribirlo al lado de símbolo de mayor que `>` y presionar `enter` para ejecutarlo. En la consola de R, el signo `>` se conoce como **prompt**, mientras que el código que escribes se llama un comando.

::: {.fragment}
``` {.r filename="Console" code-line-numbers="false"}
> 4 + 2
[1] 6
> 4 * 2
[1] 8
> 4 / 2
[1] 2
> 4**2
[1] 16
```
:::

::: {.fragment}
El número que aparece entre corchetes `[]` informa que esta línea comienza con ese valor del resultado. Algunos comandos devuelven más de un valor y sus resultados pueden ocupar múltiples líneas. Estos números se pueden ignorara en la mayoría de los casos.

Los símbolos `+`, suma; `-`, resta; `*`, multiplicación; `/`, división; `**` o `^`, exponencial; son algunos de operadores matemáticos que tiene R.
:::

## Otros operadores

::: {.fragment}
El operador dos puntos `:` devuelve todos los enteros entre dos enteros. Es una forma fácil de crear una secuencia de números.

``` {.r filename="Console" code-line-numbers="false"}
> 4:2
[1] 4 3 2
```
:::

::: {.fragment}
Los operadores de comparación son: `==` igual `!=` no igual, `>` mayor que, `<` menor que, `>=` mayor o igual que, `<=` menor o igual que.

``` {.r filename="Console" code-line-numbers="false"}
> 4 == 2
[1] FALSE
> 4 != 2
[1] TRUE
```
:::

::: {.fragment}
Los operadores lógicos son: `|` OR, `&` AND, `!` NOT.

``` {.r filename="Console" code-line-numbers="false"}
> TRUE | FALSE
[1] TRUE
> TRUE & FALSE
[1] FALSE
> TRUE & !FALSE
[1] TRUE
```
:::

## Crear objetos

Las entidades que R crea y manipula se denominan objetos. Un objeto es un nombre que puedes usar para llamar a los datos almacenados. Los objetos se crean utilizando el operador de asignación `<-`. Cuando se crea un objeto este aparecerá en el *environment pane* de RStudio. En RStudio el atajo de teclado para `<-` es {{< kbd Alt-- >}}

::: {.fragment}
``` {.r filename="console" code-line-numbers="false"}
> x <- 4 * 2
```
:::

::: {.fragment}
En R los nombres se pueden nombrar de cualquier manera, con dos excepciones. Primero, un nombre no puede comenzar con un número. Segundo, un nombre no puede usar algunos símbolos especiales, como \^, !, \$, \@, +, -, /, o \*.
:::

::: {.fragment}
### Llamar objetos

El valor de `x` no se imprime en consola, sólo se almacena. Si se quiere ver el valor, hay que llamarlo.

``` {.r filename="Console" code-line-numbers="false"}
> x
[1] 8
```
:::

## Crear objetos

::: {.fragment}
Se pueden **c**ombinar múltiples elementos en un vector usando `c()`

``` {.r filename="Console" code-line-numbers="false"}
# crear vector de números primos
numeros_primos <- c(2, 3, 5, 7, 11, 13)
```
:::

::: {.fragment}
### Operación con vectores

Así mismo, se pueden realizar operación con los vectores.

``` {.r filename="Console" code-line-numbers="false"}
# Multiplicar vector de números primos por dos.
> numeros_primos * 2
[1]  4  6 10 14 22 26
```

R ignora cualquier texto después de `#`. Esto permite escribir comentarios, texto que es ignorado por R pero leído por otras personas. Usa comentarios para explicar el porqué de tu código, no el cómo ni el qué.
:::

## Tipos de datos {.incremental}

::: {.fragment}
En R, hay 5 tipos de datos principales:

-   **numeric**: 
    -   **double**: números reales (con decimales)
    -   **integer**: números enteros
-   **character**: cadenas de texto (a.k.a. *strings*)
-   **complex**: números complejos. 
-   **logical**: `TRUE`, `FALSE`, `NA`. (a.k.a. *booleanos*)
:::

::: {.fragment}
**Para identificar el tipo de datos:**

1. `class()`: dvuelve la clase de un objeto.
2. `typeof()`: muestra el tipo de dato subyacente.
3. `mode()`: informa el modo de almacenamiento.
4. `is.numeric()`, `is.character()`, `is.logical()`, etc.: verifica si el dato es de un tipo específico.
:::

## Estructura de datos  {.incremental}

::: {.fragment}
En R, estos son las principales estructuras de datos:

-   **Vectores**: unidimensionales y homogéneos.
-   **Matrices**: bidimensionales y homogéneas.
-   **Arrays**: multidimensionales y homogéneos.
-   **Data** frames: bidimensionales y heterogéneos.
-   **Listas**: estructuras heterogéneas y unidimensionales.
-   **Factores**: datos categorizados
:::

::: {.fragment}
**Para identificar la estructura de datos:**

1. `str()`: muestra la estructura compacta del objeto.
2. `dim()`: devuelve las dimensiones (filas y columnas).
3. `length()`: número total de elementos.
4. `attributes()`: verifica los atributos del objeto.
5. `summary()`: resumen estadístico o descriptivo del objeto.
:::

## Funciones

Las funciones son bloques de código que realizan una tarea específica y que pueden ser invocadas (llamadas) desde cualquier parte. 

::: {.fragment}
En R las funciones se han de llamar así:

``` {.r filename="Console" code-line-numbers="false"}
nombre_funcion(argumento_1 = valor_1, argumento_2 = valor_2, ...)
```
:::

::: {.fragment}
Por ejemplo la función `seq()` que crea secuencias regulares de números.

``` {.r filename="Console" code-line-numbers="false"}
> seq(from = 1, to = 10)
 [1]  1  2  3  4  5  6  7  8  9 10
```
:::

::: {.fragment}
A menudo omitimos los nombres de los primeros argumentos en las llamadas a funciones, por lo que podemos reescribir esto de la siguiente manera:

``` {.r filename="Console" code-line-numbers="false"}
> seq(1, 10)
 [1]  1  2  3  4  5  6  7  8  9 10
```
:::

::: {.fragment}
Algunas funciones de R: `mean()` calcula la media de un vector. `sum()` suma los elementos de un vector. `summary()` proporciona un resumen estadístico de un objeto. `str()` muestra la estructura de un objeto.
:::

## Paquetes

Los paquetes son las unidades fundamentales del código reproducible en R. Incluyen funciones reutilizables de R, la documentación que describe cómo usarlas y datos de muestra. @wickham2023 Muchos paquetes de R se encuentran en The Comprehensive R Archive Network (CRAN). CRAN es una red de servidores FTP y web alrededor del mundo que almacenan versiones idénticas y actualizadas del código y la documentación de R.

::: {.fragment}
### Instalar y usar paquetes

En R (casi) todos los paquetes se pueden instalar utilizando la función `install.packages()`.

``` {.r filename="Console" code-line-numbers="false"}
install.packages("ethnobotanyR")
```
:::

::: {.fragment}
Para poder usar los paquetes se han de cargar (llamar) usando la función `library()`.

``` {.r filename="Console" code-line-numbers="false"}
library(ethnobotanyR)
```
::::

::: {.fragment}
Funciones de diferentes paquetes pueden tener el mismo nombre. Por lo cual es recomendable ser explicito a la hora de llamarlas, para lo cual se utilizan `::` entre el nombre del paquete y el nombre de la función.

``` {.r filename="Console" code-line-numbers="false"}
nombre_paquete::nombre_funcion()
```
:::

## Esto no es una pipa `|>`

R 4.1.0 introdujo el operador `|>` (pipe). Este operador toma la salida de una función y la pasa a otra función como argumento. Enlaza todos los pasos del análisis de datos haciendo que el código sea más eficiente y legible. 

::: {.fragment}
``` {.r filename="Console" code-line-numbers="false"}
> media_numeros_primos <- mean(c(2, 3, 5, 7, 11, 13))
> print(media_numeros_primos)
[1] 6.833333
```
:::

::: {.fragment}
``` {.r filename="Console" code-line-numbers="false"}
> numeros_primos <- c(2, 3, 5, 7, 11, 13)
> media_numeros_primos <- mean(numeros_primos)
> print(media_numeros_primos)
[1] 6.833333
```
:::

::: {.fragment}
``` {.r filename="Console" code-line-numbers="false"}
> media_numeros_primos <- 
+   c(2, 3, 5, 7, 11, 13) |> 
+   mean() |> 
+   print()
[1] 6.833333
```

En RStudio hay que activarlo yendo **Tools** -> **Global Options** -> **Code** -> **Editing**. El atajo de teclado para `|>` es {{< kbd Shift-Ctrl-M >}}
:::

## Scripts

Los scripts son archivos que contienen código en lenguaje R, organizado de manera secuencial para realizar operaciones específicas, análisis de datos, o cualquier tarea que se pueda automatizar.

::: columns
::: {.column .fragment width="60%"}
``` {.r filename="script.r" code-line-numbers="true"}
# Instalar paquetes
install.packages(
  c(
    "tidyverse",
    "palmerpenguins"
    "ggthemes"
  )
)

# Cargar paquetes
library(tidyverse)
library(palmerpenguins)
library(ggthemes)

# Crea un vector con el gráfico hecho en `ggplot2`
fig_pinguinos <- 
  palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = flipper_length_mm,
      y = body_mass_g
    )
  ) + 
  ggplot2::geom_point()

# Muestras el gráfico
fig_pinguinos
```
:::

::: {.column .fragment width="40%"}
En RStudio hay varias maneras de crear un script y otros archivos.

-   En la opción a **File** -> **New File** -> **New R script**
-   Usando el atajo de teclado {{< kbd Shift-Ctrl-N >}}
-   En la opción New File, sobre la esquina superior derecha del Source pane, en este icono ![](images/new-file.png){width="49"}
-   En la opción New Blank File de la pestaña Files en el Output pane ![](images/new-blank-file.png){width="156"}
-   Usando la Paleta de comandos {{< kbd Ctrl-Shift-P >}} o **Tools** > **Show Command Palette**

El código de un script se puede correr linea por linea usando {{< kbd Ctrl-Enter >}} o {{< kbd Ctrl-Shift-Enter >}} corre todo el script.
:::
:::

## Que alguien llame a alguien

Antes de pedir ayuda a los demás, suele ser buena idea que intentes ayudarte a ti mismo.

::: {.fragment}
### Dentro de R

La función `help()` o el operador `?` proporcionan acceso a documentación de las funciones, conjuntos de datos y otros objetos de R. Por ejemplo: `help(lm)` o `help("lm")`, o `?lm` o `?"lm"`. Si el paquete de la función no está cargado se tendría que usar `help(rlm, package="MASS")`. Para acceder a la documentación de un paquete se ha usar `help(package="MASS")`. Se puede usar `??` para una palabra o frase en la documentación.

<!-- Algunos paquetes incluyen viñetas o demos. Pueden consultarse usando: `browseVignettes` y `vignette` muestra las viñetas de los paquetes instalados. `browseVignettes(package="package-name")` muestra las viñetas del paquete buscado. `vignette("vignette-name")` muestra la viñeta buscada. `demo` muestra los demo de los paquetes instalados. `demo(package="package-name")` muestra los demo del paquete buscado. `demo("demo-name")` inicia el demo buscado. -->
:::

::: {.fragment}
### Fuera de R

::: columns
::: {.column width="50%"}
-   Google is your friend
-   Stack Overflow
-   <https://search.r-project.org>
-   <https://rseek.org>

![](images/help-me-help-you.png){fig-align="center"}
:::

::: {.column width="50%"}
Siempre es buena idea hacer un [**reprex**](https://reprex.tidyverse.org) (minimal reproducible example). Un buen reprex facilita que otras personas puedan ayudarlo y, a menudo, usted mismo descubrirá el problema durante el proceso. Hacer un reprex consiste en:

-   Hacer que tu código sea reproducible, usando `reprex`
-   Hacerlo mínimo eliminando todo lo que no esté relacionado con el problema.
:::
:::

:::

# `r fontawesome::fa("laptop-code", "white")` Actividad {background-color="#0072B2" transition="slide-in"}

-   Crear un script dentro de la carpeta `intro-r`
-   Practicar la sintaxis vista en esta sección
-   Consultar la ayuda del paquete `palmerpenguins`

<br>

<br>

```{r}
#| label: timer-1
#| echo: false

countdown_timer(15)
```

## {background-color="black" background-image="images/tidyverse.png" transition="slide-in"}

## Tidyverse

El tidyverse es una colección estructurada de paquetes de R diseñados para la ciencia de datos. Todos los paquetes comparten una filosofía de diseño subyacente, una gramática y estructuras de datos. @wickham2019.

::: {.fragment}
``` {.r filename="console" code-line-numbers="false"}
install.packages("tidyverse")
```

Carguemos el `tidyverse` y observemos la salida.

``` {.r filename="console" code-line-numbers="false"}
> library(tidyverse)
── Attaching core tidyverse packages ─────────────────────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.0     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ───────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package to force all conflicts to become errors
```
:::

## Tidyverse y la ciencia de datos

![El Tidyverse tiene multipes paquetes que nos ayudaran durante todo el proceso de analizar los datos. Tomado de @çetinkaya-rundel2023.](images/data-science_tidyverse.png){#data-science-2 fig-align="center"}

## Datos ordenados

Hay tres reglas interrelacionadas que hacen que un conjunto de datos esté ordenado:

1.  Cada variable es una columna; cada columna es una variable.
2.  Cada observación es una fila; cada fila es una observación.
3.  Cada valor es una celda; cada celda es un único valor.

::: {.fragment}
![Las siguientes tres reglas hacen que un conjunto de datos esté ordenado: las variables son columnas, las observaciones son filas y los valores son celdas. Tomado de @wickham2023a.](images/tidy-1.svg){#tidydata fig-align="center"}
:::

::: footer
Artículo original @wickham2014
:::

## Tibbles

-   **Data frame:** estructura de datos bidimensional de variables (en las columnas) y observaciones (en las filas), puede almacenar diferentes tipos de datos.

```{r}
#| label: iris
#| eval: false
#| echo: true

iris
```

```{r}
#| label: iris-slice
#| echo: false

iris |> 
  dplyr::slice_head(
    n = 5
  )
```

::: {.fragment}
-   **Tibble:** versión moderna de un data frame, optimizados para un manejo de datos más intuitivo y legible. Pertenece al `tidyverse`.

::: columns
::: {.column width="60%"}
```{r}
#| label: penguins
#| eval: false
#| echo: true

palmerpenguins::penguins
```

```{r}
#| label: penguins-slice
#| echo: false

palmerpenguins::penguins |> 
  dplyr::slice_head(
    n = 5
  )
```
:::

::: {.column width="40%"}
![](images/tibble.png){fig-align="center" width="400"}
:::
:::

:::

## Conozcamos los datos

::: columns
::: {.column width="60%"}
La función `dplyr::glimpse()` es similar a `utils::str()`, pero intenta mostrar la mayor cantidad de datos posible.

::: {.fragment fragment-index=2}
```{r}
#| label: penguins-glimpse
#| echo: true

palmerpenguins::penguins |> 
  dplyr::glimpse()
```
:::

::: {.fragment fragment-index=2}
Las tres variables de `palmerpenguins::penguins` que usaremos son:

-   `species`: la especie de un pingüino (Adelie, Chinstrap o Gentoo).
-   `flipper_length_mm`: longitud de la aleta de un pingüino, en milímetros.
-   `body_mass_g`: masa corporal de un pingüino, en gramos.
:::
:::

::: {.column .fragment fragment-index=2 width="40%"}
::: {layout-ncol=1}
![](images/lter_penguins.png)

![](images/culmen_depth.png)

Tomado de @palmerpenguins.
:::
:::
:::

::: footer
Utilice `?palmerpenguins::penguins` o `?penguins` para saber más sobre los datos.
:::

## `ggplot2`

::: columns
::: {.column width="60%"}
Sistema para la creación de gráficos. Se basa en la gramática de gráficos (marco teórico desarrollada por Leland Wilkinson para construir gráficos de manera sistemática y coherente), permitiendo construir gráficos de manera declarativa mediante capas de componentes, como datos, escalas, geoms (formas geométricas), facetas y temas.
:::

::: {.column width="40%"}
![](images/ggplot2.png){fig-align="center" width="250"}
:::
:::

::: columns
::: {.column .fragment fragment-index=2 width="50%"}
![`ggplot2` es como los ogros.](images/meme_shrek.jpeg){fig-align="center"}
:::

::: {.column .fragment fragment-index=1 width="50%"}
![Los siete componentes que permiten crear un gráfico en `ggplot2`.](images/diagram_ggplot2.png){fig-align="center"}
:::
:::

## `ggplot2` --- data {auto-animate="true"}

Para comenzar un gráfico, primero definimos un objeto gráfico usando la función `ggplot2::ggplot()`. El primer argumento de `ggplot2::ggplot()` son los datos que se utilizará en el gráfico:

```{r}
#| label: ggplot2-data
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|1,3|2"

ggplot2::ggplot(
  data = palmerpenguins::penguins
)
```

## `ggplot2` --- mapping {auto-animate="true"}

**mapping** define cómo las variables de los datos se asignan a propiedades visuales (**aesthetics**) del gráfico. Se definen con `ggplot2::aes()`. `x` e `y` especifican qué variables se asignarán a los ejes x e y.

```{r}
#| label: ggplot2-mapping
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|3-6|3,6|4|5"

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
)
```

## `ggplot2` --- layers: geometry {auto-animate="true"}

**geometry** es el objeto geométrico que se utiliza para representar datos: puntos, líneas o rectángulos. Se definen con `geom_*()`. A menudo se describen los gráficos por el tipo de geom que utilizan[^1].

[^1]: `geom_bar()` = gráficos de barras, `geom_line()` = gráficos de líneas, `geom_boxplot()` = diagramas de caja, `geom_point()` = gráficos de dispersión, entre otros.

```{r}
#| label: ggplot2-geometry
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|7-9|7|8"

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
) +
  ggplot2::geom_point()
```

## `ggplot2` --- agregando aesthetics {auto-animate="true"}

Podemos agregar más propiedades visuales (aesthetics). `ggplot2` asigna un valor único (como color) a cada nivel de una variable categórica y añade una leyenda que lo explica. Este proceso se llama **scaling**.

```{r}
#| label: ggplot2-scaling
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|6"

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g,
    color = species
  )
) +
  ggplot2::geom_point()
```

## `ggplot2` --- agregando layers {auto-animate="true"}

Podemos hacer los gráficos más informativos agregando más layers, ya sean objetos geométricos (`geom_*`), transformaciones estadísticas (`stats_*`) o ajustes de posición (`position_*`).

```{r}
#| label: ggplot2-geoms
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|10-12"

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g,
    color = species
  )
) +
  ggplot2::geom_point() + 
  ggplot2::geom_smooth(
    method = "lm"
  )
```

## `ggplot2` --- asignación global o local {auto-animate="true"}

Los aesthetics pueden agregarse de forma global para todo los geom del gráfico o pueden asignarse de forma local para un geom especifico. 

```{r}
#| label: ggplot2-asignacion
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|8-12|9-11|10"

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
) +
  ggplot2::geom_point(
    mapping = ggplot2::aes(
      color = species
    )
  ) + 
  ggplot2::geom_smooth(
    method = "lm"
  )
```

## `ggplot2` --- accesibilidad {auto-animate="true"}

Generalmente no es una buena idea representar información usando sólo colores, por lo cual podemos combinar con formas o usando paletas de colores apta para personas con limitaciones visuales.

```{r}
#| label: ggplot2-accesibilidad
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|11,17|11|17"

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
) +
  ggplot2::geom_point(
    mapping = ggplot2::aes(
      color = species,
      shape = species
    )
  ) + 
  ggplot2::geom_smooth(
    method = "lm"
  ) + 
  ggthemes::scale_color_colorblind()
```

## `ggplot2` --- scales {auto-animate="true"}

**scales** controlan cómo se traducen los datos a propiedades visuales. scales suelen formar parejas con aesthetics, y se representan en los gráficos mediante guías, como ejes o leyendas. `ggplot2::labs()` y `ggplot2::lims()` son para los ajustes más comunes de las etiquetas y los límites.

```{r}
#| label: ggplot2-labs
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|17-24|18,19|20,21|22,23"

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
) +
  ggplot2::geom_point(
    mapping = ggplot2::aes(
      color = species,
      shape = species
    )
  ) + 
  ggplot2::geom_smooth(
    method = "lm"
  ) + 
  ggplot2::labs(
    title = "Masa corporal y longitud de la aleta",
    subtitle = "Dimensiones para los Pingüinos Adelie (Adelia), Chinstrap (Barbijo) y Gentoo (Papúa)",
    x = "Longitud de la aleta (mm)",
    y = "Masa corporal (g)",
    color = "Especie",
    shape = "Especie"
  ) + 
  ggthemes::scale_color_colorblind()
```

## `ggplot2` --- theme {auto-animate="true"}

`theme` controla casi todos los elementos visuales del gráfico que no están controlados por los datos y es importante para el aspecto del gráfico. Puede utilizarse muchas de las funciones de `theme_*( )`.

```{r}
#| label: ggplot2-themes
#| echo: true
#| fig-align: center
#| output-location: column
#| code-line-numbers: "|25"

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
) +
  ggplot2::geom_point(
    mapping = ggplot2::aes(
      color = species,
      shape = species
    )
  ) + 
  ggplot2::geom_smooth(
    method = "lm"
  ) + 
  ggplot2::labs(
    title = "Masa corporal y longitud de la aleta",
    subtitle = "Dimensiones para los Pingüinos Adelie (Adelia), Chinstrap (Barbijo) y Gentoo (Papúa)",
    x = "Longitud de la aleta (mm)",
    y = "Masa corporal (g)",
    color = "Especies",
    shape = "Especies"
  ) + 
  ggplot2::theme_minimal() +
  ggthemes::scale_color_colorblind()
```

## `ggplot2` --- invocanción

::: {.fragment}
Mientras se aprende, es bueno ser explicito con los argumentos y los valores.

```{r}
#| label: ggplot2-invocando-1
#| echo: true
#| eval: false

ggplot2::ggplot(
  data = palmerpenguins::penguins,
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
) +
  ggplot2::geom_point()
```
:::

::: columns
::: {.column .fragment width="50%"}
Es común que se omita el nombre de los argumentos o que se adopten estilos o formas de escribir código.

```{r}
#| label: ggplot2-invocando-2
#| echo: true
#| eval: false

ggplot2::ggplot(
  palmerpenguins::penguins,
  ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
) +
  ggplot2::geom_point()
```
:::

::: {.column .fragment width="50%"}
Lo anterior, en un flujo de trabajo usando `|>` se vería así:

```{r}
#| label: ggplot2-invocando-3
#| echo: true
#| eval: false

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = flipper_length_mm,
      y = body_mass_g)
  ) +
  ggplot2::geom_point()
```
:::
:::

::: footer
Uno de los estilos recomendables es [la guía de estilo del tidyverse](https://style.tidyverse.org)
:::

# `r fontawesome::fa("laptop-code", "white")` Actividad {background-color="#0072B2" transition="slide-in"}

-   Abrir el archivo `ggplot.qmd` que se encuentra en la carpeta `intro-r`
-   Realizar la **Actividad 1**.

<br>

<br>

```{r}
#| label: timer-2
#| echo: false

countdown_timer(15)
```

# `r fontawesome::fa("mug-saucer", "white")` Pausa {background-color="#000000" transition="slide-in"}

<br>

<br>

```{r}
#| label: timer-6
#| echo: false

countdown_timer(10)
```

# Visualizando distribuciones

## Una variable categórica

::: columns
::: {.column .fragment width="50%"}
Una variable es categórica si toma uno de varios valores limitados. Para analizar su distribución, se usa un gráfico de barras, donde la altura indica cuántas observaciones tiene cada valor.

::: {.fragment}
```{r}
#| label: ggplot2-categorica-1
#| echo: true
#| fig-align: center
#| output-location: fragment 

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = species
    )
  ) +
  ggplot2::geom_bar()
```
:::
:::

::: {.column .fragment width="50%"}
En gráficos de barras con categorías no ordenadas, es útil reordenar las barras por frecuencia. Se hace convirtiendo la variable en un factor y reordenando los niveles con `forcats::fct_infreq()`.

::: {.fragment}
```{r}
#| label: ggplot2-categorica-2
#| echo: true
#| fig-align: center
#| output-location: fragment 

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = forcats::fct_infreq(species)
    )
  ) +
  ggplot2::geom_bar()
```
:::
:::
:::

## Una variable numérica

Una variable es numérica (o cuantitativa) si puede tomar una amplia gama de valores numéricos y tiene sentido sumarlos, restarlos o calcular promedios con esos valores. Las variables numéricas pueden ser continuas o discretas. Una visualización comúnmente utilizada para distribuciones de variables continuas es un histograma.

::: {.fragment}
```{r}
#| label: ggplot2-histogram
#| echo: true
#| fig-align: center
#| output-location: column-fragment

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = body_mass_g
    )
  ) +
  ggplot2::geom_histogram(
    binwidth = 200
  )
```
:::

## Una variable numérica

Un gráfico de densidad es una versión suavizada de un histograma y una alternativa práctica, especialmente para datos continuos que provienen de una distribución subyacente suave. Muestra menos detalles que un histograma, pero puede facilitar la comprensión rápida de la forma de la distribución, especialmente con respecto a la moda y la asimetría.

::: {.fragment}
```{r}
#| label: ggplot2-density
#| echo: true
#| fig-align: center
#| output-location: column-fragment

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = body_mass_g
    )
  ) +
  ggplot2::geom_density()
```
:::

# Visualizando relaciones

## Una variable numérica y categórica

Para visualizar la relación entre una variable numérica y una variable categórica, podemos usar diagramas de caja (box plots). Un diagrama de caja es un tipo de representación visual para medidas de posición (percentiles) que describen una distribución. También es útil para identificar posibles valores atípicos.

::: {.fragment}
```{r}
#| label: ggplot2-boxplot
#| echo: true
#| fig-align: center
#| output-location: column-fragment

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = species,
      y = body_mass_g
    )
  ) +
  ggplot2::geom_boxplot()
```
:::

## Una variable numérica y categórica

Alternativamente, podemos hacer gráficos de densidad con `ggplot2::geom_density()`.

::: columns
::: {.column .fragment width="50%"}
```{r}
#| label: ggplot2-numerica-categorica-1
#| echo: true
#| fig-align: center
#| output-location: fragment 

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = body_mass_g,
      color = species
      
    )
  ) +
  ggplot2::geom_density(
    linewidth = 0.75
  )
```
:::

::: {.column .fragment width="50%"}
```{r}
#| label: ggplot2-numerica-categorica-2
#| echo: true
#| fig-align: center
#| output-location: fragment 

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = body_mass_g,
      color = species,
      fill = species
    )
  ) +
  ggplot2::geom_density(
    alpha = 0.5
  )
```
:::
:::

## Dos variables categóricas

Podemos utilizar gráficos de barras apiladas para visualizar la relación entre dos variables categóricas.

::: columns
::: {.column .fragment width="50%"}
```{r}
#| label: ggplot2-dos-categoricas-1
#| echo: true
#| fig-align: center
#| output-location: fragment 

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = island,
      fill = species
    )
  ) +
  ggplot2::geom_bar()
```
:::

::: {.column .fragment width="50%"}
```{r}
#| label: ggplot2-dos-categoricas-2
#| echo: true
#| fig-align: center
#| output-location: fragment
#| code-line-numbers: "|8"

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = island,
      fill = species
    )
  ) +
  ggplot2::geom_bar(position = "fill")
```
:::
:::

## Dos variables numéricas
Un diagrama de dispersión es probablemente el gráfico más utilizado para visualizar la relación entre dos variables numéricas.

::: {.fragment}
```{r}
#| label: ggplot2-dos-numericas
#| echo: true
#| fig-align: center
#| output-location: column-fragment

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = flipper_length_mm,
      y = body_mass_g
    )
  ) +
  ggplot2::geom_point(
    ggplot2::aes(
      color = species,
      shape = island
    )
  )
```
:::

## Tres o más variables

En `ggplot2` podemos incorporar más variables en un gráfico asignándolas a estéticas adicionales. Agregar demasiadas asignaciones estéticas a un gráfico lo hace confuso y difícil de interpretar. Una forma particularmente útil para variables categóricas es dividir el gráfico en **facets**, subgráficos que muestran cada uno un subconjunto de los datos.

::: {.fragment}
```{r}
#| label: ggplot2-tres-variables
#| echo: true
#| fig-align: center
#| output-location: column-fragment

palmerpenguins::penguins |> 
  ggplot2::ggplot(
    ggplot2::aes(
      x = flipper_length_mm,
      y = body_mass_g
    )
  ) +
  ggplot2::geom_point(
    ggplot2::aes(
      color = species,
      shape = species
    )
  ) + 
  ggplot2::facet_wrap(
    ~island
  )
```
:::

## Problemas comunes con `ggplot2`

Un problema común al crear gráficos con ggplot2 es colocar el `+` en el lugar incorrecto: debe ir al final de la línea, no al inicio.

::: columns
::: {.column .fragment width="50%"}
### Forma incorrecta

```{r}
#| label: ggplot2-incorrecta
#| eval: false
#| echo: true

ggplot2::ggplot(
  data = palmerpenguins::penguins
) 
+ ggplot2::geom_point(
  mapping = ggplot2::aes(
    x = flipper_length_mm,
    y = body_mass_g
  )
)
```
:::

::: {.column .fragment width="50%"}
### Forma correcta: 

```{r}
#| label: ggplot2-correcta
#| eval: true
#| echo: true
#| fig-align: center

ggplot2::ggplot(
  data = palmerpenguins::penguins
) + 
  ggplot2::geom_point(
    mapping = ggplot2::aes(
      x = flipper_length_mm,
      y = body_mass_g
    )
  )
```
:::
:::

## Resumen de `ggplot2`

::: {.fragment}
### Asignación global

```{r}
#| label: ggplot2-asignacion-global
#| eval: false
#| echo: true

DATA |> 
  ggplot2::ggplot(
    ggplot2::aes(MAPPINGS)
  ) + 
  ggplot2::geom_*()
```
:::

::: {.fragment}
### Asignación local

```{r}
#| label: ggplot2-asignacion-local
#| eval: false
#| echo: true

DATA |> 
  ggplot2::ggplot(
    ggplot2::aes(MAPPINGS)
  ) + 
  ggplot2::geom_*(ggplot2::aes(MAPPINGS))
```
:::

# `r fontawesome::fa("laptop-code", "white")` Actividad {background-color="#0072B2" transition="slide-in"}

-   Abrir el archivo `ggplot.qmd` que se encuentra en la carpeta `intro-r`
-   Realizar la **Actividad 2**.

<br>

<br>

```{r}
#| label: timer-3
#| echo: false

countdown_timer(15)
```

# «En el principio era el Verbo»

## Tidyverse y la ciencia de datos

![El Tidyverse tiene multipes paquetes que nos ayudaran durante todo el proceso de analizar los datos. Tomado de @çetinkaya-rundel2023.](images/data-science_tidyverse.png){#data-science-2 fig-align="center"}

## `dplyr`

::: columns
::: {.column .fragment width="50%"}
`dplyr` es una gramática de transformación de datos que proporciona un conjunto consistente de verbos (funciones) que ayudan a resolver los desafíos de manipulación de datos más comunes. 

![](images/dplyr.png){fig-align="center" width="250"}
:::

::: {.column .fragment width="50%"}
Todas las funciones tienen estás características en común:

1.    El primer argumento es siempre un data frame.
2.    Los argumentos siguientes suelen describir las columnas sobre las que se va a operar utilizando los nombres de las variables (sin comillas).
3.    La salida es siempre un nuevo data frame.
:::
:::

::: {.fragment}
Los verbos de `dplyr` están organizados en cuatro grupos basados en lo que operan:

::: columns
::: {.column width="25%"}
### Filas
-   `arrange()`
-   `distinct()`
-   `filter()`
-   `slice_*()`
:::

::: {.column width="25%"}
### Columnas
-   `mutate()`
-   `relocate()`
-   `rename()`
-   `select()`
:::

::: {.column width="25%"}
### Grupos
-   `count()`
-   `group_by()`
-   `summarise()`
:::

::: {.column width="25%"}
### Data frames
-   `*_join()`
:::
:::

:::

## `dplyr` --- filas: `arrange()`

::: {.fragment}
`arrange()` Ordena las filas utilizando los valores de las columnas

```{r}
#| label: dplyr-arrange
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::arrange(island)
```
:::

::: {.fragment}
Para ordenar de mayor a menor se ha de usar `dplyr::desc()` dentro de `dplyr::arrange()`.

```{r}
#| label: dplyr-desc
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::arrange(dplyr::desc(island))
```
:::

## `dplyr` --- filas: `distinct()`

::: {.fragment}
`distinct()` Mantiene filas distintas/únicas

```{r}
#| label: dplyr-distinct
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::distinct(island)
```
:::

## `dplyr` --- filas: `filter()`

::: {.fragment}
`filter()` Mantiene las filas que cumplen una condición

```{r}
#| label: dplyr-filter
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::filter(island == "Dream")
```
:::

::: {.fragment}
Hay muchas funciones y operadores que resultan útiles a la hora de construir las expresiones utilizadas para filtrar los datos:

-   Operadores de comparación (`==`, `!=`, `>`, `<`, `>=`, `<=`)
-   Operadores lógicos (`|`, `&`, `!`)
-   `base::is.na()`
-   `dplyr::between()`, `dplyr::near()`
:::

## `dplyr` --- filas: `slice_()*`

::: {.fragment}
`slice_()*` Subconjunto de filas utilizando sus posiciones

```{r}
#| label: dplyr-slice
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::slice_min(body_mass_g, n = 5)
```
:::

::: {.fragment}
Podemos encontrar varias funciones: `dplyr::slice()`, `dplyr::slice_head()`, `dplyr::slice_tail()`, `dplyr::slice_min()`, `dplyr::slice_max()`, `dplyr::slice_sample()`.
:::

## `dplyr` --- filas: ejemplo

```{r}
#| label: dplyr-ejemplo-filas
#| eval: true
#| echo: true
#| fig-align: center
#| output-location: fragment
#| code-line-numbers: "|1|2-4|5-8|9-11|12-15"

palmerpenguins::penguins |>
  dplyr::filter(
    species == "Chinstrap"
  ) |> 
  dplyr::slice_max(
    body_mass_g,
    n = 5
  ) |> 
  dplyr::arrange(
    bill_length_mm
  ) |> 
  dplyr::distinct(
    flipper_length_mm,
    .keep_all = TRUE
  )
```

## `dplyr` --- columnas: `mutate()`

::: {.fragment}
`mutate()` Crear, modificar y eliminar columnas

```{r}
#| label: dplyr-mutate
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::mutate(
    volume = (pi * bill_depth_mm * bill_length_mm) / 3,
    .after = bill_depth_mm
  )
```
:::

::: {.fragment}
Hay muchas funciones que pueden ser usadas, `?dplyr::mutate()` para ver un listado de ellas.
:::

## `dplyr` --- columnas: `pull()`

::: {.fragment}
`pull()` Extraer una sola columna

```{r}
#| label: dplyr-pull
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::pull(species)
```
:::

## `dplyr` --- columnas: `relocate()`

::: {.fragment}
`relocate()` Cambiar el orden de las columnas

```{r}
#| label: dplyr-relocate
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::relocate(
    year,
    sex
  )
```
:::

::: {.fragment}
`dplyr::relocate()` tiene dos argumentos muy útiles *.before* y *.after*.
:::

## `dplyr` --- columnas: `rename()`

::: {.fragment}
`rename()` Renombrar columnas

```{r}
#| label: dplyr-rename
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::rename(
    Pygoscelis = species
  )
```
:::

::: {.fragment}
La sintaxis siempre es `nuevo_nombre = viejo_nombre`. 

`rename_with()` renombra columnas utilizando una función. 

Si se tiene un montón de columnas con nombres inconsistentes y sería complicado corregirlas todas manualmente, consulte `janitor::clean_names()`.
:::

## `dplyr` --- columnas: `select()`

::: {.fragment}
`select()` Mantener o eliminar columnas utilizando sus nombres y tipos

```{r}
#| label: dplyr-select
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::select(
    species,
    sex
  )
```
:::

::: {.fragment}
Las selecciones del Tidyverse implementan un dialecto de R en el que los operadores facilitan la selección de variables: `:` selecciona un rango de variables consecutivas. `!` toma el complemento de un conjunto de variables. `&` y `|` selecciona la intersección o la unión de dos conjuntos de variables. `c()` para combinar selecciones.

Además, puede utilizar ayudantes de selección. `?dplyr::select()` para ver el listado completo.
:::

## `dplyr` --- columnas: ejemplo

```{r}
#| label: dplyr-ejemplo-columnas
#| echo: true
#| output-location: fragment
#| code-line-numbers: "|1|2-4|5-7|8-12"

palmerpenguins::penguins |> 
  dplyr::rename(
    pygoscelis = species
  ) |> 
  dplyr::mutate(
    volume = (pi * bill_depth_mm * bill_length_mm) / 3,
  ) |> 
  dplyr::select(
    pygoscelis,
    volume,
    body_mass_g:sex
  )
```

## `dplyr` --- grupos: `count()`

::: {.fragment}
`count()` Contar las observaciones de cada grupo

```{r}
#| label: dplyr-count
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::count(
    species,
    island
  )
```
:::

::: {.fragment}
Al utilizar `sort = TRUE` como argumento, se mostrará los grupos más grandes en la parte superior.

`dplyr::add_count()` y `dplyr::add_tally()` son equivalentes a `dplyr::count()` y `dplyr::tally()` pero utilizan `dplyr::mutate()` en lugar de `dplyr::summarise()` para añadir una nueva columna con recuentos por grupos.
:::

## `dplyr` --- grupos: `group_by()`

::: {.fragment}
`group_by()` Agrupar por una o varias variables

```{r}
#| label: dplyr-group-by
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::group_by(
    species,
    island
  )
```
:::

::: {.fragment}
`dplyr::group_by()` no cambia los datos pero, si observa detenidamente la salida, se dará cuenta de que la salida indica que está «agrupada por» (`Groups: species, island [5]`). Esto significa que las operaciones posteriores funcionarán ahora por grupo. Por lo cual es recomendable usar `dplyr::ungroup()` cuando sea necesario.
:::

## `dplyr` --- grupos: `summarise()`

::: {.fragment}
`summarise()` Resumir cada grupo en una fila

```{r}
#| label: dplyr-summarise
#| echo: true
#| output-location: fragment

palmerpenguins::penguins |> 
  dplyr::group_by(
    species,
    island
  ) |> 
  dplyr::summarise(
    n = dplyr::n()
  )
```
:::

::: {.fragment}
La operación de agrupamiento más importante. Reduce el data frame para que tenga una sola fila para cada grupo. `dplyr::summarise()` y `dplyr::summarize()` son sinónimos.

Funciones útiles: centrales (`base::mean()`, `base::median()`), dispersión (`base::sd()`, `base::IQR()`, `base::mad()`), rango (`base::min()`, `base::max()`), posición (`dplyr::first()`, `dplyr::last()`, `dplyr::nth()`), recuento (`dplyr::n()`, `dplyr::n_distinto()`), lógicas (`dplyr::any()`, `dplyr::all()`).
:::

## `dplyr` --- grupos: ejemplo

```{r}
#| label: dplyr-ejemplo-grupos
#| echo: true
#| output-location: fragment
#| code-line-numbers: "|1|2-6|7-10"

palmerpenguins::penguins |> 
  dplyr::group_by(
    species,
    island,
    sex
  ) |> 
  dplyr::summarise(
    mean_body_mass_g = base::mean(body_mass_g, na.rm = TRUE),
    n = dplyr::n()
  )
```

## `dplyr` --- data frames

::: columns
::: {.column width="40%"}
::: {.fragment fragment-index=1}
Las uniones de transformación (mutating joins) agregan nuevas variables a un data frame a partir de las observaciones coincidentes en otra tabla. Hay cuatro uniones de transformación: la unión interior (inner join) y las tres uniones exteriores (outer joins).
:::

::: {.fragment fragment-index=3}
Las uniones de filtro (filtering joins) filtran observaciones en un data frame con base en si coinciden o no con una observación de otra tabla.

Las operaciones de conjuntos (set operations) que tratan las observaciones como elementos de un conjunto.
:::
:::

::: {.column .fragment fragment-index=2 width="60%"}
![Tomado de @choueiry2024.](images/mutating_joins.png){fig-align="center"}
:::
:::

# `r fontawesome::fa("laptop-code", "white")` Actividad {background-color="#0072B2" transition="slide-in"}

-   Abrir el archivo `dplyr.qmd` que se encuentra en la carpeta `intro-r`
-   Realizar la **Actividad**.

<br>

<br>

```{r}
#| label: timer-4
#| echo: false

countdown_timer(15)
```

## Tidyverse y la ciencia de datos

![El Tidyverse tiene multipes paquetes que nos ayudaran durante todo el proceso de analizar los datos. Tomado de @çetinkaya-rundel2023.](images/data-science_tidyverse.png){#data-science-2 fig-align="center"}

## Importando los datos

Hay varias maneras de importar los datos. Todo depende del formato en que estos se encuentren, aunque lo ideal es siempre tenerlos en formatos de texto plano: .csv, .tsv, txt.

::: columns
::: {.column .fragment width="50%"}
### Texto plano

![](images/readr.png){fig-align="center" width="250"}

Hay varias funciones: `reardr::read_csv()`, `reardr::read_tsv()`, `reardr::read_csv2()`, `reardr::read_delim()`.

```{r}
#| label: read-csv
#| eval: false
#| echo: true

reardr::read_csv(
  "ruta/al/archivo/archivo.csv"
)
```
:::

::: {.column .fragment width="50%"}
### Excel

![](images/readxl.png){fig-align="center" width="250"}

Hay varias funciones: `readxl::()read_excel`, `readxl::()read_xls`, `readxl::()read_xlsx`.

```{r}
#| label: read-excel
#| eval: false
#| echo: true

readxl::read_excel(
  "ruta/al/archivo/archivo.xlsx"
)
```
:::
:::

## {background-color="black" background-image="images/hay_tabla.jpg" transition="slide-in"}

## Tablas

Hay varios paquetes para realizar tablas en R. Cada uno con enfoques, curvas de aprendizaje y formatos de salida diferentes. Una forma de agruparlos es si producen tablas estáticas o tablas dinámicas.

![](images/r-packages-for-table-summary.png){fig-align="center}

::: footer
[2024 Table Contest](https://posit.co/blog/2024-table-contest-winners/)
:::

## Organizando los datos

La idea de una tabla es que sea informativa y legible, por lo cual es recomendable hacer una buena selección de los datos.

::: {.fragment}
```{r}
#| label: organizando-datos
#| echo: true
#| output-location: column-fragment
#| code-line-numbers: "|1|2|3-7|8-11|12-14|15|17"

penguins_resumen <- 
  palmerpenguins::penguins |> 
  dplyr::count(
    species,
    island,
    sex
  ) |> 
  dplyr::group_by(
    species,
    island
  ) |> 
  dplyr::mutate(
    percentage = n / sum(n) * 100
  ) |> 
  dplyr::ungroup()

penguins_resumen
```
:::

## `knitr::kable()` {.scrollable}

`kable()` es un generador de tablas muy simple, y es simple por diseño. Sólo genera tablas para datos estrictamente rectangulares. No puede formatear mucho las celdas de la tabla ni combinar celdas. Algunas de las limitaciones de `knitr::kable()` pueden ser subsanadas utilizando el paquete `kableExtra`.

::: {.fragment}
```{r}
#| label: kable
#| echo: true
#| output-location: column-fragment
#| code-line-numbers: "|1|2-12|13-18"

penguins_resumen |> 
  dplyr::mutate(
    species = base::paste0(
      "*", species, "*"
    ),
    sex = dplyr::case_match(
      sex,
      "female" ~ "Hembra",
      "male" ~ "Macho",
      .default = sex
    )
  ) |> 
  knitr::kable(
    col.names = c(
      "Especie", "Isla", "Sexo", "n", "Porcentaje (%)"
    ),
    digits = c(2)
  )
```
:::

## `gt`

`gt` permite construir una amplia variedad de tablas útiles con un conjunto cohesivo de partes de tabla.

![](images/gt_parts_of_a_table.png){.r-stretch fig-align="center"}

## `gt` --- ejemplo

```{r}
#| label: gt
#| echo: true
#| output-location: column-fragment
#| code-line-numbers: "|1|2|3-10|11-14|15-18|19-25|26-29|30"

penguins_resumen |> 
  gt::gt() |>
  gt::tab_style(
    style = gt::cell_text(
      style = "italic"
    ),
    locations = gt::cells_body(
      columns = species,
    )
  ) |> 
  gt::sub_values(
    value = "female",
    replacement = "Hembra"
  ) |> 
  gt::sub_values(
    value = "male",
    replacement = "Macno"
  ) |>
  gt::cols_label(
    species = "Especie", 
    island = "Isla", 
    sex = "Sexo", 
    n = "n", 
    percentage = "Porcentaje (%)"
  ) |> 
  gt::fmt_number(
    columns = "percentage",
    decimals = 2
  ) |> 
  gt::opt_stylize(style = 1)
```

## `flextable`

`flextable` proporciona un marco para crear fácilmente tablas para informes y publicaciones. Un objeto `flextable` es una representación data.frame compuesto por tres partes (header, body, footer). El paquete proporciona funciones que permiten controlar estas tres partes y texto, párrafos, celdas,formato de borde de cualquier elemento y valores mostrados.

![](images/flextable_layout.png){fig-align="center"}

## `flextable` --- ejemplo

```{r}
#| label: flextable
#| echo: true
#| output-location: column-fragment
#| code-line-numbers: "|1|2|3-6|7-11|12-16|17-22|23-25|26-29|30|31"

penguins_resumen |> 
  flextable::flextable() |> 
  flextable::mk_par(
    j = "species",
    value = flextable::as_paragraph(flextable::as_i(species)),
  ) |>
  flextable::mk_par(
    i = ~ sex == "female",
    j = "sex",
    value = flextable::as_paragraph("Hembra")
  ) |> 
  flextable::mk_par(
    i = ~ sex == "male",
    j = "sex",
    value = flextable::as_paragraph("Macho")
  ) |> 
  flextable::set_header_labels(
    species = "Especie",
    island = "Isla",
    sex = "Sexo",
    percentage = "Porcentaje (%)"
  ) |> 
  flextable::merge_v(
    j = c("species", "island")
  ) |> 
  flextable::colformat_char(
    j = "sex",
    na_str = "NA",
  ) |> 
  flextable::theme_apa() |> 
  flextable::autofit()
```

## Recursos
-   [1 dataset. 100 visualizations](https://100.datavizproject.com)
-   [Cleaning Biodiversity Data in R](https://cleaning-data-r.ala.org.au)
-   [Data Viz Project](https://datavizproject.com/)
-   [From Data to Viz](https://www.data-to-viz.com)
-   [ggplot2: Elegant Graphics for Data Analysis (3e)](https://ggplot2-book.org/index.html)
-   [gt](https://gt.rstudio.com)
-   [Hands-On Programming with R](https://jjallaire.github.io/hopr/)
-   [R Cookbook, 2nd Edition](https://rc2e.com)
-   [R for Data Science (2e)](https://r4ds.hadley.nz)
-   [R for Plant Disease Epidemiology](https://r4pde.netlify.app)
-   [R Graphics Cookbook, 2nd edition](https://r-graphics.org)
-   [The R Graph Gallery](https://r-graph-gallery.com/index.html)
-   [Tidyverse](https://www.tidyverse.org)
-   [Using the flextable R package](https://ardata-fr.github.io/flextable-book/index.html)

# `r fontawesome::fa("mug-saucer", "white")` Pausa {background-color="#000000" transition="slide-in"}

<br>

<br>

```{r}
#| label: timer-5
#| echo: false

countdown_timer(15)
```

## Referencias {visibility="uncounted"}
